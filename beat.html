<head>
    <meta charset="utf-8" />
    <meta name="author" content="@stephband" />
    <meta name="description" content="TODO" />
    <meta name="viewport" content="width=device-width" />

    <script>
        window.DEBUG = true;
    </script>

    <script type="importmap">{
        "imports": {
            "dom/":        "../dom/modules/",
            "fn/":         "../fn/modules/",
            "form/":       "../form-elements/",
            "literal/":    "../literal/",
            "midi/":       "../midi/modules/",
            "soundstage/": "../soundstage/modules/"
        }
    }</script>

    <link rel="stylesheet" href="../bolt/elements/html.css" />
    <link rel="stylesheet" href="../bolt/elements/table.css" />
    <link rel="stylesheet" href="../bolt/elements/label.css" />
    <link rel="stylesheet" href="../bolt/elements/form.css" />
    <link rel="stylesheet" href="../bolt/elements/svg.css" />
    <link rel="stylesheet" href="../bolt/classes/block.css" />
    <link rel="stylesheet" href="../bolt/classes/atoms.css" />
    <link rel="stylesheet" href="../bolt/classes/button.css" />

    <style>
        html, body {
            height: 100%;
        }

        html {
            background-color: #646568;
        }

        body {
            padding: 1.875rem 1.5rem;
            padding: 0;
        }

        body > header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            text-align: right;
            z-index: 2;
            max-height: 0;
        }

        body > header > file-menu {
            margin-top: 0.1875rem;
            margin-right: 0.375rem;
        }

        body > stage-graph {
            height: 100vh;
            overflow: auto;
        }

        canvas {
            background-color: rgba(0,0,0,0.2);
        }

        .body-grid {
            grid-template-columns: 1fr min(33%, 18rem);
            column-gap: 0;
            row-gap: 0;
        }

        .body-grid > header {
            grid-column: auto;
            grid-row: auto;
        }

        .body-grid > .block {
            padding-top: 3rem;
        }

        .body-grid > .px-canvas {
            position: absolute;
            bottom: 0;
            left: 0;
            grid-column: auto;
            grid-row: auto;
        }

        .graph {
            display: grid;
            grid-auto-columns: 0rem;
            grid-auto-rows: 0rem;
            column-gap: 1.5rem;
            row-gap: 1.5rem;
            min-height: 6rem;
        }

        .graph > * {
            z-index: 2;
        }

        stage-graph {
            display: flex;
            flex-direction: column;
            position: relative;
            background-color: #eeeeee;
        }

        stage-graph > header,
        stage-graph > footer,
        stage-graph > section {
            width: 100%;
            padding-left: 0.75rem;
            padding-right: 0.75rem;
        }

        stage-graph > header,
        stage-graph > footer {
            display: flex;
            height: 1.875rem;
            background-color: #dddddd;
        }

        stage-graph > header {
            top: 0;
            align-items: start;
        }

        stage-graph > header > h2 {
            margin-left: auto;
            margin-right: auto;
        }

        stage-graph > header + section {
            height: clac(100vh - 60px);
            padding-top: 2.625rem;
            padding-bottom: 2.625rem;
        }

        stage-graph > footer {
            margin-top: auto;
            bottom: 0;
            align-items: end;
        }

        .graph > stage-midi-in {
            grid-column-end: span 6;
            grid-row-end: span 2;
        }

        .graph > stage-midi-out {
            grid-column-end: span 6;
            grid-row-end: span 2;
        }

        .graph > stage-harmoniser {
            grid-column-end: span 10;
            grid-row-end: span 8;
        }

        .graph > stage-button {
            grid-column-end: span 8;
            grid-row-end: span 6;
        }

        .graph > stage-transform {
            grid-column-end: span 15;
            grid-row-end: span 6;
        }

        .graph > note-radar {
            grid-column-end: span 15;
            grid-row-end: span 15;
        }

        .midi-monitor {
            position: fixed;
            bottom: 0;
            right: 0;
            width: auto;
            height: auto;
            max-height: 100vh;
            font-family: 'FiraMono', AndaleMono, monospace;
            font-size: 0.875rem;
            text-align: right;
            white-space: pre;
            color: #999999;
            z-index: 0;
        }
    </style>

    <script type="module">
        import LiteralHTML from 'literal/literal-html/module.js';
        import Event from 'soundstage/event.js';
        import denormalise from 'fn/denormalise.js';
        import normalise from 'fn/normalise.js';
        import { angle, magnitude } from './modules/vector.js';
        import fft, { ifft } from './modules/fft.js';
        window.EVENT = Event;
        window.fft = fft;
        window.ifft = ifft;
        window.angle = angle;
        window.magnitude = magnitude;
        window.normalise = normalise;
        window.denormalise = denormalise;
    </script>

    <!--
        import FileMenu    from 'form/file-menu/module.js';

        import NodeGraph   from './elements/stage-graph/module.js';
        import Monitor     from './elements/stage-monitor/module.js';
        import MIDIIn      from './elements/stage-midi-in/module.js';
        import MIDIOut     from './elements/stage-midi-out/module.js';
        import Transform   from './elements/stage-transform/module.js';
        import Harmoniser  from './elements/stage-harmoniser/module.js';
        import Button      from './elements/stage-button/module.js';

        import Data        from 'fn/data.js';
        import delegate    from 'dom/delegate.js';
        import events      from 'dom/events.js';
        import Graph       from './modules/graph.js';

        // TODO: move this to literal scope
        window.headerTypes = ['midiin'];
        window.footerTypes = ['midiout'];

        function setupStage(data) {
            const graph = new Graph(data.nodes, data.pipes);
            fileMenu.data = graph;
            Data.of(window).graph = graph;
            window.graph = graph;
        }

        const fileMenu = document.getElementById('stage-file-menu');

        events('change', document).each(delegate({
            '#stage-file-menu': (element, e) => setupStage(element.data)
        }));

        setupStage({
            nodes: [
               // { id: 1, type: 'midiin' },
                //{ id: 2, type: 'midiout' },
                { id: 3, type: 'button' },
                //{ id: 4, type: 'transform' },
                //{ id: 5, type: 'harmoniser' },
                { id: 6, type: 'monitor' }
            ],

            pipes: [
                3, 0, 6, 0
            ]

            /*pipes: [
                1, 0, 2, 3,
                3, 0, 2, 12,
                1, 8, 4, 0,
                4, 0, 2, 3,
                5, 1, 4, 0
            ]*/
        });
    -->

    <template id="harmonic">
        <label class="${ 'x' + (DATA.i + 1) } y1" style="margin-top: 0; padding: 0; min-height: 0;">${ data.i }</label>
        <input class="${ 'x' + (DATA.i + 1) } y2" style="margin-top: 0;" type="number" name="harmonic-${ DATA.i }-gain" min="0" max="${ 1 / DATA.i }" step="any" />
        <input class="${ 'x' + (DATA.i + 1) } y3" style="margin-top: 0;" type="number" name="harmonic-${ DATA.i }-phase" min="0" max="${ 2 * PI }" step="any" />
    </template>

    <template id="scope">
        <canvas width="1024" height="512" class="block">${ ((canvas) => {
            const ctx = canvas.getContext('2d');

            // It's a transform, really, not a box: origin at y, y scale inverted
            const box = [0, 0.5 * canvas.height, canvas.width, -0.4 * canvas.height];

            const axisStyle     = { strokeStyle: "rgba(0,0,0,0.4)", lineWidth: 0.5 };
            const axisZeroStyle = { strokeStyle: "rgba(0,0,0,1)", lineWidth: 0.5 };
            function plotYAxis(box, style) {
                let [x, y, w, h] = box;

                // y lines
                let n = 2;
                ctx.beginPath();
                while ((n /= 2) > 0.008) {
                    ctx.moveTo(x,     y - n * h);
                    ctx.lineTo(x + w, y - n * h);
                    ctx.moveTo(x,     y + n * h);
                    ctx.lineTo(x + w, y + n * h);
                }
                assign(ctx, axisStyle, style);
                ctx.stroke();
                ctx.closePath();

                // y=0 line
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y);
                assign(ctx, axisZeroStyle, style);
                ctx.stroke();
                ctx.closePath();
            }

            const plotStyle     = { strokeStyle: "white", lineWidth: 1 };
            function plot(box, points, style) {
                const [x, y, w, h] = box;
                let n = -1;
                ctx.beginPath();
                ctx.moveTo(points[++n] * w + x, points[++n] * h + y);
                while(points[++n] !== undefined) ctx.lineTo(points[n] * w + x, points[++n] * h + y);
                assign(ctx, plotStyle, style);
                ctx.stroke();
                ctx.closePath();
            }

            const waveformStyle = { strokeStyle: "white", lineWidth: 1 };
            function plotWaveform(box, samples, style) {
                let [x, y, w, h] = box;
                let dx = w / samples.length;
                let n = -1;
                ctx.beginPath();
                ctx.moveTo(x, samples[++n] * h + y);
                while(samples[++n] !== undefined) ctx.lineTo(x += dx, samples[n] * h + y);
                ctx.lineTo(x += dx, samples[0] * h + y);
                assign(ctx, waveformStyle, style);
                ctx.stroke();
                ctx.closePath();
            }

            function plotBuffer(box, buffer, style) {
                let n = -1;
                while(++n < buffer.numberOfChannels) plotWaveform(box, buffer.getChannelData(n), style);
            }

            function draw() {
                plotYAxis(box);
                plotWaveform(box, DATA.samples);
            }

            draw();






            // Calculate Frequency Bins
            // Returns an array of the frequencies (in hertz) of
            // each FFT bin provided
            function fftFreq(fftBins, sampleRate) {
                var stepFreq = sampleRate / (2 * fftBins.length);
                return fftBins.map(function (n, i) {
                    return i * stepFreq;
                });
            }

            // A length of 1024 gives us an analysis of 512 harmonics after fft
            let samples = DATA.samples.slice(0);
            //plotWaveform([0, 0.5 * canvas.height, canvas.width, (-0.4/1) * canvas.height], samples, { strokeStyle: "white" });

            let phasors = fft(samples);

            let magnitudes  = phasors.map(magnitude);
            magnitudes.length *= 0.5;
            let maxMag      = Math.max.apply(Math, magnitudes);
            magnitudes.forEach((n, i, a) => a[i] /= maxMag);
            plotWaveform([0, 0.9 * canvas.height, canvas.width, (-0.8/1) * canvas.height], magnitudes.slice(0, 128), { strokeStyle: "#B2D732" });

            let angles = phasors
            .map(angle)
            // Ignore phase angles where magnitude is insignificant, they are noise
            .map((n, i) => magnitudes[i] < 0.000000001 ? 0 : n / Math.PI);

            angles.length *= 0.5;
            plotWaveform([0, 0.5 * canvas.height, canvas.width, (-0.4/1) * canvas.height], angles.slice(0, 128), { strokeStyle: "rgb(214,198,51)" });

            console.table({
                magnitude: magnitudes.slice(0, 8).map((n) => n.toFixed(2))
            });

            // Change a phasor
            //console.log(phasors);
            //phasors[60][0] += 300;
            //phasors[60][1] /= -3;

            // Do the inverse FFT to check we are recreating the signal properly
            let ss = ifft(phasors);
            //plotWaveform([0, 0.5 * canvas.height, canvas.width, (-0.4/1) * canvas.height], ss, { strokeStyle: "orange" });

            // All phases should be 0, or very near 0
            ss.forEach((m) => {
                if (m[1] < -0.000000001 && m[1] > 0.000000001) {
                    console.log('PHASE NOT 0!!!');
                }
            });

            let mags = ss.map(get(0));

            //let maxMg = Math.max.apply(Math, mags);
            //mags.forEach((n, i, a) => a[i] /= maxMg);
            plotWaveform([0, 0.5 * canvas.height, canvas.width, (-0.4/1) * canvas.height], mags, { strokeStyle: "white" });

            function searchUpwardZeroCrossings(samples) {
                const crossings = [];

                let n = 0;
                while (samples[++n] !== undefined) {
                    // Sample is -ve or 0, it cannot be from an upward 0 crossing
                    if (samples[n] <= 0) continue;

                    // Previous sample was -ve or 0, crossing detected
                    if (samples[n - 1] <= 0) {
                        crossings.push({
                            x:        (n - 1 + normalise(samples[n - 1], samples[n], 0)) / samples.length,
                            gradient: (samples[n] - samples[n - 1]) * samples.length / (2 * Math.PI)
                        });
                    }

                    // Minor optimisation. Sample is above 0 so next iteration
                    // cannot be an upward zero crossing, skip an n
                    ++n;
                }

                return crossings;
            }

            const hits = searchUpwardZeroCrossings(samples)
            .map((crossing) => EVENT.of(crossing.x, 'start', 0, crossing.gradient));

            hits.forEach((event) => {
                plot(box, [
                    event[0], 0,
                    event[0], event[3]
                ], { strokeStyle: "orange", lineWidth: 2 });
            });

            console.log('HITS', hits);





            // Event encoding

            function eventsToCrossings(events) {
                return events.reduce((crossings, event) => {
                    if (event[1] === 'start') {
                        crossings.push({
                            x:        event[0],
                            gradient: event[3]
                        });
                    }

                    return crossings;
                }, []);
            }

            function crossingsToWaveform(crossings, samples = new Float32Array(2048)) {
                // Approximate a sinusoidal wave to match a series of
                // zero crossings. There is nothing 'pure' about this function,
                // It's a best guess approach.

                let n = -1;
                let cl = crossings[crossings.length - 1];
                let c1 = { x: cl.x - 1, gradient: cl.gradient };
                let c2;

                while ((c2 = crossings[++n]) !== undefined) {
                    const scale = c2.x - c1.x;
                    const s0 = c1.gradient;
                    const s3 = c2.gradient;
                    const n0 = c1.x * samples.length;
                    const n3 = c2.x * samples.length;
                    const n1 = Math.ceil(n0);
                    const n2 = Math.ceil(n3);

                    // Fill in samples with one scaled-start, scaled-end sine
                    // cycle
                    let n = n1 - 1;
                    while (++n < n2) {
                        // Progress 0-1 through these samples
                        let p = normalise(n0, n3, n);
                        // Linear scaling over time. TODO: ease scaling
                        // logarithmically, it is essentially tempo info here.
                        // I think. Linear scaling is definitely going to add
                        // harmonics, making this fn lass than ideal. But still
                        // not terrible. It may be good enough.
                        let s = denormalise(s0, s3, p);
                        samples[n < 0 ? samples.length + n : n] = s * scale * sin(p * 2 * PI);
                    }

                    c1 = c2;
                }

                return samples;
            }

            const events = [
                EVENT.of(0,    'start', 0, 1),
                EVENT.of(0.51, 'start', 0, 0.5),
                EVENT.of(0.75, 'start', 0, 0.25)
            ];

            const crossings = eventsToCrossings(events);
            const samps     = crossingsToWaveform(crossings);

            plotWaveform(box, samps, { strokeStyle: "aquamarine" });

        })(element) }</canvas>
        <pre>${ DATA.samples.length } samples</pre>
        <div class="grid" style="--x-gap: 0.1875rem; --y-gap: 0.1875rem;">
            ${ Array.from({ length: 16 }, (v, i) => ({ i })).map(include('#harmonic')) }
        </div>
    </template>
</head>

<body class="">
    <template is="literal-html" data-length="2048">
        <!--${ include('#scope', {
            samples: Array.from({ length: data.length }, (n, i) => {
                const p = i / data.length;
                return p < 0.25 ? p :
                    p < 0.75 ? 0.5 + -p :
                    p - 1 ;
            })
        }) }-->

        ${ include('#scope', {
            samples: Array.from({ length: data.length }, (n, i) => {
                return 0
                    + 0.1 * sin(-0.3 + PI * 2 * i / data.length)
                    //+ 0.5 * (1/2) * sin(Math.PI * 4 * i / data.length)
                    //+ 0.5 * (1/3) * sin(Math.PI * 6 * i / data.length)
                    + 0.5 * (1/4) * sin(Math.PI * 8 * i / data.length)
                    //+ 0.25 * (1/5) * sin(Math.PI * 10 * i / data.length)
                    + 0.5 * (1/6) * sin(Math.PI * 12 * i / data.length)
                    //+ 0.5 * (1/7) * sin(Math.PI * 14 * i / data.length)
                    //+ 0.5 * (1/8) * sin(Math.PI * 16 * i / data.length)
                    //+ 0.5 * (1/9) * sin(Math.PI * 18 * i / data.length)
                    //+ 0.5 * (1/10) * sin(Math.PI * 20 * i / data.length)
                    //+ 0.5 * (1/11) * sin(Math.PI * 22 * i / data.length)
                    //+ 0.5 * (1/12) * sin(Math.PI * 24 * i / data.length)
                    //+ 0.5 * (1/13) * sin(Math.PI * 26 * i / data.length)
                    //+ 0.5 * (1/14) * sin(Math.PI * 28 * i / data.length)
                    //+ 0.5 * (1/15) * sin(Math.PI * 30 * i / data.length)
                    //+ 0.5 * (1/16) * sin(Math.PI * 32 * i / data.length) ;
            })
        }) }
    </template>
</body>
